# coding: utf-8

"""
    mailsac API Specification

    ## About the API  The Mailsac API allows for interacting with Mailsac services, including checking email, email validations, setting up forwarding addresses, receiving web socket email messages, and sending outbound mail.  [**Get a free API key**](https://mailsac.com/api-keys)  Test the Mailsac API online:  * [**Swagger UI Explorer** &rarr;](https://mailsac.com/docs/swagger)  **Base API Endpoint**:  * `https://mailsac.com/api/` * _All API documentation is relative to this endpoint._  **OpenAPI Spec**:  * [Download JSON](https://mailsac.com/openapi.json) * [Download YAML](https://mailsac.com/openapi.yml)   ### Support and Resources  * [npm Node.js and Browser library - @mailsac/api](https://www.npmjs.com/package/@mailsac/api) * [Full Documentation and Guides](https://docs.mailsac.com) * [Community Support and Discussion Forums](https://forum.mailsac.com/forums/) * [Web socket example in Node.js - ruffrey](https://github.com/ruffrey/mailsac-node-websocket-example)  Paid Email Support, Pre-Sales    > support@team.mailsac.com  [Terms of Service](https://docs.mailsac.com/en/latest/about/terms_of_service.html)  [Privacy Policy](https://docs.mailsac.com/en/latest/about/privacy_policy.html)   # noqa: E501

    OpenAPI spec version: 1.0.2
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from client.api_client import ApiClient


class MessagesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_message_label(self, email, message_id, label, **kwargs):  # noqa: E501
        """Add a label to a message  # noqa: E501

        To help organize messages and group messages together, add a label to a message. Labels are used in the Inbox UI to group messages.  When successful, returns 200 with a subset of the message object.  When the label already exists on the message, the message is not modified and the API endpoint returns 200.  No PUT body is needed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_message_label(email, message_id, label, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param MessageLabel label: Label for email message - must be url encoded (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_message_label_with_http_info(email, message_id, label, **kwargs)  # noqa: E501
        else:
            (data) = self.add_message_label_with_http_info(email, message_id, label, **kwargs)  # noqa: E501
            return data

    def add_message_label_with_http_info(self, email, message_id, label, **kwargs):  # noqa: E501
        """Add a label to a message  # noqa: E501

        To help organize messages and group messages together, add a label to a message. Labels are used in the Inbox UI to group messages.  When successful, returns 200 with a subset of the message object.  When the label already exists on the message, the message is not modified and the API endpoint returns 200.  No PUT body is needed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_message_label_with_http_info(email, message_id, label, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param MessageLabel label: Label for email message - must be url encoded (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'message_id', 'label']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_message_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `add_message_label`")  # noqa: E501
        # verify the required parameter 'message_id' is set
        if ('message_id' not in params or
                params['message_id'] is None):
            raise ValueError("Missing the required parameter `message_id` when calling `add_message_label`")  # noqa: E501
        # verify the required parameter 'label' is set
        if ('label' not in params or
                params['label'] is None):
            raise ValueError("Missing the required parameter `label` when calling `add_message_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501
        if 'message_id' in params:
            path_params['messageId'] = params['message_id']  # noqa: E501
        if 'label' in params:
            path_params['label'] = params['label']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/addresses/{email}/messages/{messageId}/labels/{label}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def count_messages(self, email, **kwargs):  # noqa: E501
        """Count messages for an email inbox  # noqa: E501

        Get the number of messages for an email inbox address. **It is NOT necessary to reserve the address** before using this route. Whether it is an address on a custom domain, or a public domain, or mailsac.com, the mail can be counted as long as nobody else owns it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.count_messages(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.count_messages_with_http_info(email, **kwargs)  # noqa: E501
        else:
            (data) = self.count_messages_with_http_info(email, **kwargs)  # noqa: E501
            return data

    def count_messages_with_http_info(self, email, **kwargs):  # noqa: E501
        """Count messages for an email inbox  # noqa: E501

        Get the number of messages for an email inbox address. **It is NOT necessary to reserve the address** before using this route. Whether it is an address on a custom domain, or a public domain, or mailsac.com, the mail can be counted as long as nobody else owns it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.count_messages_with_http_info(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method count_messages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `count_messages`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/addresses/{email}/message-count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_all_domain_messages(self, domain, **kwargs):  # noqa: E501
        """Delete all messages in a domain  # noqa: E501

        Delete all messages for a specifc domain. Starred messages will be deleted.  The domain must be owned domain.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_all_domain_messages(domain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DomainString domain: Domain (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_all_domain_messages_with_http_info(domain, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_all_domain_messages_with_http_info(domain, **kwargs)  # noqa: E501
            return data

    def delete_all_domain_messages_with_http_info(self, domain, **kwargs):  # noqa: E501
        """Delete all messages in a domain  # noqa: E501

        Delete all messages for a specifc domain. Starred messages will be deleted.  The domain must be owned domain.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_all_domain_messages_with_http_info(domain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DomainString domain: Domain (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_all_domain_messages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain' is set
        if ('domain' not in params or
                params['domain'] is None):
            raise ValueError("Missing the required parameter `domain` when calling `delete_all_domain_messages`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain' in params:
            path_params['domain'] = params['domain']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/domains/{domain}/delete-all-domain-mail', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_all_messages(self, email, **kwargs):  # noqa: E501
        """Delete all messages for an email inbox  # noqa: E501

        This deletes all messages for a specific email address.  The address must be an owned address or an address in a owned domain. Starred messages will not be deleted. Use `DELETE /addresses/{email}/messages/{messageId}` to remove starred messages or unstar the messages before calling this route.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_all_messages(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param ModelDate until: Return messages returned up to this UTC date
        :param Limit limit:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_all_messages_with_http_info(email, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_all_messages_with_http_info(email, **kwargs)  # noqa: E501
            return data

    def delete_all_messages_with_http_info(self, email, **kwargs):  # noqa: E501
        """Delete all messages for an email inbox  # noqa: E501

        This deletes all messages for a specific email address.  The address must be an owned address or an address in a owned domain. Starred messages will not be deleted. Use `DELETE /addresses/{email}/messages/{messageId}` to remove starred messages or unstar the messages before calling this route.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_all_messages_with_http_info(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param ModelDate until: Return messages returned up to this UTC date
        :param Limit limit:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'until', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_all_messages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `delete_all_messages`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501

        query_params = []
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/addresses/{email}/messages', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_message(self, email, message_id, **kwargs):  # noqa: E501
        """Delete an email message  # noqa: E501

        Deletes an individual email message. There is no trash or undo.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_message(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_message_with_http_info(email, message_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_message_with_http_info(email, message_id, **kwargs)  # noqa: E501
            return data

    def delete_message_with_http_info(self, email, message_id, **kwargs):  # noqa: E501
        """Delete an email message  # noqa: E501

        Deletes an individual email message. There is no trash or undo.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_message_with_http_info(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'message_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `delete_message`")  # noqa: E501
        # verify the required parameter 'message_id' is set
        if ('message_id' not in params or
                params['message_id'] is None):
            raise ValueError("Missing the required parameter `message_id` when calling `delete_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501
        if 'message_id' in params:
            path_params['messageId'] = params['message_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/addresses/{email}/messages/{messageId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_message_label(self, email, message_id, label, **kwargs):  # noqa: E501
        """Remove a label from a message  # noqa: E501

        Removes a label from a message. Returns 200 with a subset of the message object when successful.  When the label did not exists on the message, the message is not modified and the API endpoint returns 200.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_message_label(email, message_id, label, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param MessageLabel label: Label for email message - must be url encoded (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_message_label_with_http_info(email, message_id, label, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_message_label_with_http_info(email, message_id, label, **kwargs)  # noqa: E501
            return data

    def delete_message_label_with_http_info(self, email, message_id, label, **kwargs):  # noqa: E501
        """Remove a label from a message  # noqa: E501

        Removes a label from a message. Returns 200 with a subset of the message object when successful.  When the label did not exists on the message, the message is not modified and the API endpoint returns 200.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_message_label_with_http_info(email, message_id, label, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param MessageLabel label: Label for email message - must be url encoded (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'message_id', 'label']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_message_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `delete_message_label`")  # noqa: E501
        # verify the required parameter 'message_id' is set
        if ('message_id' not in params or
                params['message_id'] is None):
            raise ValueError("Missing the required parameter `message_id` when calling `delete_message_label`")  # noqa: E501
        # verify the required parameter 'label' is set
        if ('label' not in params or
                params['label'] is None):
            raise ValueError("Missing the required parameter `label` when calling `delete_message_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501
        if 'message_id' in params:
            path_params['messageId'] = params['message_id']  # noqa: E501
        if 'label' in params:
            path_params['label'] = params['label']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/addresses/{email}/messages/{messageId}/labels/{label}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def filter_inbox_messages(self, **kwargs):  # noqa: E501
        """Filter messages in account by to, from, and/or subject  # noqa: E501

        Filter account messages within the the `to` and `from` `.address` fields, and the `subject` line. This differs from `/api/inbox-search` by using logical AND, rather than OR in `/api/inbox-search`.  At least one query condition is required, otherwise a 400 will be returned.  A maximum of 100 results will ever be returned. Refine the query or reduce the number of messages in the account to find specific items.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filter_inbox_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str and_subject_includes: Messages must include this text in the subject line
        :param str and_from: Messages must include this text in FROM envelope
        :param str and_to: Messages must include this text in TO envelope or the `message.inbox` is equal to this value
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.filter_inbox_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.filter_inbox_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def filter_inbox_messages_with_http_info(self, **kwargs):  # noqa: E501
        """Filter messages in account by to, from, and/or subject  # noqa: E501

        Filter account messages within the the `to` and `from` `.address` fields, and the `subject` line. This differs from `/api/inbox-search` by using logical AND, rather than OR in `/api/inbox-search`.  At least one query condition is required, otherwise a 400 will be returned.  A maximum of 100 results will ever be returned. Refine the query or reduce the number of messages in the account to find specific items.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filter_inbox_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str and_subject_includes: Messages must include this text in the subject line
        :param str and_from: Messages must include this text in FROM envelope
        :param str and_to: Messages must include this text in TO envelope or the `message.inbox` is equal to this value
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['and_subject_includes', 'and_from', 'and_to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method filter_inbox_messages" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'and_subject_includes' in params:
            query_params.append(('andSubjectIncludes', params['and_subject_includes']))  # noqa: E501
        if 'and_from' in params:
            query_params.append(('andFrom', params['and_from']))  # noqa: E501
        if 'and_to' in params:
            query_params.append(('andTo', params['and_to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/inbox-filter', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_body_dirty(self, email, message_id, **kwargs):  # noqa: E501
        """Get message HTML body (dirty)  # noqa: E501

        Get a message's HTML content.  Attached images are inlined and nothing has been stripped.  When no HTML body was sent in the original message, a simple HTML body will be created.  Use the querystring param ?download=1 to trigger file download in browser.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_body_dirty(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param int download: Download to browser
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_body_dirty_with_http_info(email, message_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_body_dirty_with_http_info(email, message_id, **kwargs)  # noqa: E501
            return data

    def get_body_dirty_with_http_info(self, email, message_id, **kwargs):  # noqa: E501
        """Get message HTML body (dirty)  # noqa: E501

        Get a message's HTML content.  Attached images are inlined and nothing has been stripped.  When no HTML body was sent in the original message, a simple HTML body will be created.  Use the querystring param ?download=1 to trigger file download in browser.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_body_dirty_with_http_info(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param int download: Download to browser
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'message_id', 'download']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_body_dirty" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `get_body_dirty`")  # noqa: E501
        # verify the required parameter 'message_id' is set
        if ('message_id' not in params or
                params['message_id'] is None):
            raise ValueError("Missing the required parameter `message_id` when calling `get_body_dirty`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501
        if 'message_id' in params:
            path_params['messageId'] = params['message_id']  # noqa: E501

        query_params = []
        if 'download' in params:
            query_params.append(('download', params['download']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/dirty/{email}/{messageId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_body_plain_text(self, email, message_id, **kwargs):  # noqa: E501
        """Get message plaintext  # noqa: E501

        Get a message's text content. If the original message only contained HTML, a simple plain text body will be generated.  HTTP links in the plain text email will be available when fetching the message's metadata at the `message.links[]` property.  Use the querystring param ?download=1 to trigger file download in browser.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_body_plain_text(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param int download: Download to browser
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_body_plain_text_with_http_info(email, message_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_body_plain_text_with_http_info(email, message_id, **kwargs)  # noqa: E501
            return data

    def get_body_plain_text_with_http_info(self, email, message_id, **kwargs):  # noqa: E501
        """Get message plaintext  # noqa: E501

        Get a message's text content. If the original message only contained HTML, a simple plain text body will be generated.  HTTP links in the plain text email will be available when fetching the message's metadata at the `message.links[]` property.  Use the querystring param ?download=1 to trigger file download in browser.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_body_plain_text_with_http_info(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param int download: Download to browser
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'message_id', 'download']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_body_plain_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `get_body_plain_text`")  # noqa: E501
        # verify the required parameter 'message_id' is set
        if ('message_id' not in params or
                params['message_id'] is None):
            raise ValueError("Missing the required parameter `message_id` when calling `get_body_plain_text`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501
        if 'message_id' in params:
            path_params['messageId'] = params['message_id']  # noqa: E501

        query_params = []
        if 'download' in params:
            query_params.append(('download', params['download']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/text/{email}/{messageId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_body_sanitized(self, email, message_id, **kwargs):  # noqa: E501
        """Get the message HTML body (sanitized)  # noqa: E501

        Get safe HTML from an email message. Scripts, images and links are stripped out. This HTML is safer to render than the potentially \"dirty\" original HTML.  When no HTML body was sent in the original message, a simple HTML body will be created.  Use the querystring param ?download=1 to trigger file download in browser.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_body_sanitized(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param int download: Download to browser
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_body_sanitized_with_http_info(email, message_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_body_sanitized_with_http_info(email, message_id, **kwargs)  # noqa: E501
            return data

    def get_body_sanitized_with_http_info(self, email, message_id, **kwargs):  # noqa: E501
        """Get the message HTML body (sanitized)  # noqa: E501

        Get safe HTML from an email message. Scripts, images and links are stripped out. This HTML is safer to render than the potentially \"dirty\" original HTML.  When no HTML body was sent in the original message, a simple HTML body will be created.  Use the querystring param ?download=1 to trigger file download in browser.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_body_sanitized_with_http_info(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param int download: Download to browser
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'message_id', 'download']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_body_sanitized" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `get_body_sanitized`")  # noqa: E501
        # verify the required parameter 'message_id' is set
        if ('message_id' not in params or
                params['message_id'] is None):
            raise ValueError("Missing the required parameter `message_id` when calling `get_body_sanitized`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501
        if 'message_id' in params:
            path_params['messageId'] = params['message_id']  # noqa: E501

        query_params = []
        if 'download' in params:
            query_params.append(('download', params['download']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/body/{email}/{messageId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_full_raw_message(self, email, message_id, **kwargs):  # noqa: E501
        """Get original SMTP message  # noqa: E501

        Gets the entire original SMTP message transport - everything that was sent over the network to Mailsac's inbound servers, plus any Mailsac-generated `Received` headers, and special `x-mailsac-*` headers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_full_raw_message(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param int download: Download to browser
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_full_raw_message_with_http_info(email, message_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_full_raw_message_with_http_info(email, message_id, **kwargs)  # noqa: E501
            return data

    def get_full_raw_message_with_http_info(self, email, message_id, **kwargs):  # noqa: E501
        """Get original SMTP message  # noqa: E501

        Gets the entire original SMTP message transport - everything that was sent over the network to Mailsac's inbound servers, plus any Mailsac-generated `Received` headers, and special `x-mailsac-*` headers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_full_raw_message_with_http_info(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param int download: Download to browser
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'message_id', 'download']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_full_raw_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `get_full_raw_message`")  # noqa: E501
        # verify the required parameter 'message_id' is set
        if ('message_id' not in params or
                params['message_id'] is None):
            raise ValueError("Missing the required parameter `message_id` when calling `get_full_raw_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501
        if 'message_id' in params:
            path_params['messageId'] = params['message_id']  # noqa: E501

        query_params = []
        if 'download' in params:
            query_params.append(('download', params['download']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/raw/{email}/{messageId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_headers(self, email, message_id, **kwargs):  # noqa: E501
        """Get parsed message headers  # noqa: E501

        Returns pre-parsed message headers in one of 3 formats - `json`, `json-ordered`, or `plain`.  If no querystring parameter is provided, the default format will be `json`.  Every email is different; fields in the below examples are not guaranteed to exist.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_headers(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param int download: Download to browser
        :param str message_headers_format:
        :return: MessageHeaders
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_headers_with_http_info(email, message_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_headers_with_http_info(email, message_id, **kwargs)  # noqa: E501
            return data

    def get_headers_with_http_info(self, email, message_id, **kwargs):  # noqa: E501
        """Get parsed message headers  # noqa: E501

        Returns pre-parsed message headers in one of 3 formats - `json`, `json-ordered`, or `plain`.  If no querystring parameter is provided, the default format will be `json`.  Every email is different; fields in the below examples are not guaranteed to exist.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_headers_with_http_info(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param int download: Download to browser
        :param str message_headers_format:
        :return: MessageHeaders
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'message_id', 'download', 'message_headers_format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_headers" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `get_headers`")  # noqa: E501
        # verify the required parameter 'message_id' is set
        if ('message_id' not in params or
                params['message_id'] is None):
            raise ValueError("Missing the required parameter `message_id` when calling `get_headers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501
        if 'message_id' in params:
            path_params['messageId'] = params['message_id']  # noqa: E501

        query_params = []
        if 'download' in params:
            query_params.append(('download', params['download']))  # noqa: E501
        if 'message_headers_format' in params:
            query_params.append(('messageHeadersFormat', params['message_headers_format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/addresses/{email}/messages/{messageId}/headers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageHeaders',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_message_metadata(self, email, message_id, **kwargs):  # noqa: E501
        """Get email message metadata  # noqa: E501

        Retrieves metadata about a single email message. This route includes additional metadata not available when listing messages, such as parsed links from the text or HTML body, and attachment md5sums.  To get even more information about message attachments, like filenames, see the Attachments API.  To get the entire original SMTP message, see the \"raw\" message route.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_metadata(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :return: EmailMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_message_metadata_with_http_info(email, message_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_message_metadata_with_http_info(email, message_id, **kwargs)  # noqa: E501
            return data

    def get_message_metadata_with_http_info(self, email, message_id, **kwargs):  # noqa: E501
        """Get email message metadata  # noqa: E501

        Retrieves metadata about a single email message. This route includes additional metadata not available when listing messages, such as parsed links from the text or HTML body, and attachment md5sums.  To get even more information about message attachments, like filenames, see the Attachments API.  To get the entire original SMTP message, see the \"raw\" message route.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_metadata_with_http_info(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :return: EmailMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'message_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_message_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `get_message_metadata`")  # noqa: E501
        # verify the required parameter 'message_id' is set
        if ('message_id' not in params or
                params['message_id'] is None):
            raise ValueError("Missing the required parameter `message_id` when calling `get_message_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501
        if 'message_id' in params:
            path_params['messageId'] = params['message_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/addresses/{email}/messages/{messageId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmailMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_domain_messages(self, domain, **kwargs):  # noqa: E501
        """List messages for an domain  # noqa: E501

        Get a list of messages across any inboxes of a domain. Messages are always **sorted in decending order by when they were received**, with the newest message always in the first position of the array.  The email message objects are abbreviated to provide basic meta data. To get more information about a specific message, use `GET /api/addresses/{email}/messages/{messageId}`.  The domain must be owned by the account making the request, and have DNS validated. Paginate with `until?=<Date>` and `limit=<uint>`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_domain_messages(domain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DomainString domain: Domain (required)
        :param ModelDate until: Return messages returned up to this UTC date
        :param Limit limit:
        :return: EmailMessageShort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_domain_messages_with_http_info(domain, **kwargs)  # noqa: E501
        else:
            (data) = self.list_domain_messages_with_http_info(domain, **kwargs)  # noqa: E501
            return data

    def list_domain_messages_with_http_info(self, domain, **kwargs):  # noqa: E501
        """List messages for an domain  # noqa: E501

        Get a list of messages across any inboxes of a domain. Messages are always **sorted in decending order by when they were received**, with the newest message always in the first position of the array.  The email message objects are abbreviated to provide basic meta data. To get more information about a specific message, use `GET /api/addresses/{email}/messages/{messageId}`.  The domain must be owned by the account making the request, and have DNS validated. Paginate with `until?=<Date>` and `limit=<uint>`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_domain_messages_with_http_info(domain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DomainString domain: Domain (required)
        :param ModelDate until: Return messages returned up to this UTC date
        :param Limit limit:
        :return: EmailMessageShort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain', 'until', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_domain_messages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain' is set
        if ('domain' not in params or
                params['domain'] is None):
            raise ValueError("Missing the required parameter `domain` when calling `list_domain_messages`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain' in params:
            path_params['domain'] = params['domain']  # noqa: E501

        query_params = []
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/domains/{domain}/messages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmailMessageShort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_inbox_messages(self, **kwargs):  # noqa: E501
        """Get all account messages paginated  # noqa: E501

        Used by the Inbox UI to display all messages for the account, across all domains and private addresses.  Returns email message short metadata, paginated, with the global account unread message count.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_inbox_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Limit limit:
        :param ModelDate since: Only fetch messages since this date
        :param Skip skip:
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_inbox_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_inbox_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_inbox_messages_with_http_info(self, **kwargs):  # noqa: E501
        """Get all account messages paginated  # noqa: E501

        Used by the Inbox UI to display all messages for the account, across all domains and private addresses.  Returns email message short metadata, paginated, with the global account unread message count.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_inbox_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Limit limit:
        :param ModelDate since: Only fetch messages since this date
        :param Skip skip:
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'since', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_inbox_messages" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/inbox', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_messages(self, email, **kwargs):  # noqa: E501
        """List messages for an email inbox  # noqa: E501

        Get a list of messages for the email address. Messages are always **sorted in decending order by when they were received**, with the newest message always in the first position of the array.  The email message objects are abbreviated to provide basic meta data. To get more information about a specific message, use `GET /api/addresses/{email}/messages/{messageId}`.  **It is NOT necessary to reserve the address** before checking mail! Whether it is an address on a custom domain, or a public domain, or mailsac.com, the mail can be checked with this route.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_messages(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param ModelDate until: Return messages returned up to this UTC date
        :param Limit limit:
        :return: EmailMessageShort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_messages_with_http_info(email, **kwargs)  # noqa: E501
        else:
            (data) = self.list_messages_with_http_info(email, **kwargs)  # noqa: E501
            return data

    def list_messages_with_http_info(self, email, **kwargs):  # noqa: E501
        """List messages for an email inbox  # noqa: E501

        Get a list of messages for the email address. Messages are always **sorted in decending order by when they were received**, with the newest message always in the first position of the array.  The email message objects are abbreviated to provide basic meta data. To get more information about a specific message, use `GET /api/addresses/{email}/messages/{messageId}`.  **It is NOT necessary to reserve the address** before checking mail! Whether it is an address on a custom domain, or a public domain, or mailsac.com, the mail can be checked with this route.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_messages_with_http_info(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param ModelDate until: Return messages returned up to this UTC date
        :param Limit limit:
        :return: EmailMessageShort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'until', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_messages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `list_messages`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501

        query_params = []
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/addresses/{email}/messages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmailMessageShort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_starred_messages(self, **kwargs):  # noqa: E501
        """List starred (saved) messages on the account  # noqa: E501

        Get a list of messages that have been saved and made private for the entire account using the \"star message\" feature.  Messages recieved via the Capture Service will also show up as starred IF the `capturePrivate` flag on the account is enabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_starred_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EmailMessageList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_starred_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_starred_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_starred_messages_with_http_info(self, **kwargs):  # noqa: E501
        """List starred (saved) messages on the account  # noqa: E501

        Get a list of messages that have been saved and made private for the entire account using the \"star message\" feature.  Messages recieved via the Capture Service will also show up as starred IF the `capturePrivate` flag on the account is enabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_starred_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EmailMessageList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_starred_messages" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/addresses/starred/messages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmailMessageList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_inbox_messages(self, **kwargs):  # noqa: E501
        """Search messages by to, from, and subject  # noqa: E501

        Search all account messages within the the `to` and `from` `.address` fields, and the `subject` line. This differs from `/api/inbox-filter` by using logical OR, rather than AND in `/api/inbox-filter`.  A maximum of 100 results will ever be returned. Refine the query or reduce the number of messages in the account to find specific items.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_inbox_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query: Searches to, from, and subject for all messages on this account, limited to 100 results.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_inbox_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_inbox_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_inbox_messages_with_http_info(self, **kwargs):  # noqa: E501
        """Search messages by to, from, and subject  # noqa: E501

        Search all account messages within the the `to` and `from` `.address` fields, and the `subject` line. This differs from `/api/inbox-filter` by using logical OR, rather than AND in `/api/inbox-filter`.  A maximum of 100 results will ever be returned. Refine the query or reduce the number of messages in the account to find specific items.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_inbox_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query: Searches to, from, and subject for all messages on this account, limited to 100 results.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_inbox_messages" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/inbox-search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_message_folder(self, email, message_id, folder, **kwargs):  # noqa: E501
        """Move a message into a folder  # noqa: E501

        Move the message to a different mail folder.  No new folders can be added. To organize mail, use labels.  No PUT body is needed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_message_folder(email, message_id, folder, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param MessageFolder folder: Folder for email organization (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_message_folder_with_http_info(email, message_id, folder, **kwargs)  # noqa: E501
        else:
            (data) = self.set_message_folder_with_http_info(email, message_id, folder, **kwargs)  # noqa: E501
            return data

    def set_message_folder_with_http_info(self, email, message_id, folder, **kwargs):  # noqa: E501
        """Move a message into a folder  # noqa: E501

        Move the message to a different mail folder.  No new folders can be added. To organize mail, use labels.  No PUT body is needed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_message_folder_with_http_info(email, message_id, folder, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param MessageFolder folder: Folder for email organization (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'message_id', 'folder']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_message_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `set_message_folder`")  # noqa: E501
        # verify the required parameter 'message_id' is set
        if ('message_id' not in params or
                params['message_id'] is None):
            raise ValueError("Missing the required parameter `message_id` when calling `set_message_folder`")  # noqa: E501
        # verify the required parameter 'folder' is set
        if ('folder' not in params or
                params['folder'] is None):
            raise ValueError("Missing the required parameter `folder` when calling `set_message_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501
        if 'message_id' in params:
            path_params['messageId'] = params['message_id']  # noqa: E501
        if 'folder' in params:
            path_params['folder'] = params['folder']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/addresses/{email}/messages/{messageId}/folder/{folder}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_message_read_status(self, email, message_id, read_boolean, **kwargs):  # noqa: E501
        """Set message read/unread status  # noqa: E501

        Change the read state of a message.  Pass `readBoolean` as `true` to mark the message as read, and `false` to mark it as unread. The default for any new message `false` (unread).  No PUT body is needed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_message_read_status(email, message_id, read_boolean, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param ReadBoolean read_boolean: Set message read/unread (required)
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_message_read_status_with_http_info(email, message_id, read_boolean, **kwargs)  # noqa: E501
        else:
            (data) = self.set_message_read_status_with_http_info(email, message_id, read_boolean, **kwargs)  # noqa: E501
            return data

    def set_message_read_status_with_http_info(self, email, message_id, read_boolean, **kwargs):  # noqa: E501
        """Set message read/unread status  # noqa: E501

        Change the read state of a message.  Pass `readBoolean` as `true` to mark the message as read, and `false` to mark it as unread. The default for any new message `false` (unread).  No PUT body is needed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_message_read_status_with_http_info(email, message_id, read_boolean, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :param ReadBoolean read_boolean: Set message read/unread (required)
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'message_id', 'read_boolean']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_message_read_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `set_message_read_status`")  # noqa: E501
        # verify the required parameter 'message_id' is set
        if ('message_id' not in params or
                params['message_id'] is None):
            raise ValueError("Missing the required parameter `message_id` when calling `set_message_read_status`")  # noqa: E501
        # verify the required parameter 'read_boolean' is set
        if ('read_boolean' not in params or
                params['read_boolean'] is None):
            raise ValueError("Missing the required parameter `read_boolean` when calling `set_message_read_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501
        if 'message_id' in params:
            path_params['messageId'] = params['message_id']  # noqa: E501
        if 'read_boolean' in params:
            path_params['readBoolean'] = params['read_boolean']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/addresses/{email}/messages/{messageId}/read/{readBoolean}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def toggle_message_star(self, email, message_id, **kwargs):  # noqa: E501
        """Star (save) a message  # noqa: E501

        Toggle a message's *starred* status so it will not be automatically recycled when the account's message storage limit is reached.  There is no PUT body.  It returns only the message metadata.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.toggle_message_star(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :return: EmailMessageShort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.toggle_message_star_with_http_info(email, message_id, **kwargs)  # noqa: E501
        else:
            (data) = self.toggle_message_star_with_http_info(email, message_id, **kwargs)  # noqa: E501
            return data

    def toggle_message_star_with_http_info(self, email, message_id, **kwargs):  # noqa: E501
        """Star (save) a message  # noqa: E501

        Toggle a message's *starred* status so it will not be automatically recycled when the account's message storage limit is reached.  There is no PUT body.  It returns only the message metadata.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.toggle_message_star_with_http_info(email, message_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailString email: Email address (required)
        :param MessageId message_id: Mailsac-generated globally unique message identifier (required)
        :return: EmailMessageShort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'message_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method toggle_message_star" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `toggle_message_star`")  # noqa: E501
        # verify the required parameter 'message_id' is set
        if ('message_id' not in params or
                params['message_id'] is None):
            raise ValueError("Missing the required parameter `message_id` when calling `toggle_message_star`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501
        if 'message_id' in params:
            path_params['messageId'] = params['message_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyHeader', 'APIKeyQueryParam']  # noqa: E501

        return self.api_client.call_api(
            '/addresses/{email}/messages/{messageId}/star', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmailMessageShort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
